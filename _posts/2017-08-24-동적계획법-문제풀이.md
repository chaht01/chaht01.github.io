---
layout: post
title: "동적계획법 문제풀이"
date:   2017-08-24 13:57:55 +0900
categories: Algorithm
comments: true
---



### 동적계획법

백준에서 다양한 동적계획법 문제를 풀어보실 수 있습니다. 한국어로 ‘동적계획법'으로 소개되고 있는 Dynamic programming(DP)는 ‘최적의 답'을 내기 위한 다양한 경우를 고려해야 하는 상황에서 그 위력을 발휘합니다.

기본적으로 사람보다 컴퓨터가 잘하는 것이 ‘빠르게 여러번' 반복하는거라 생각합니다. 때문에 실제 겪는 문제 상황들, 이를테면 ‘가장 빠른 길은?’, ‘가장 비용을 최소화 하는 방법은?’, ‘가장 이득을 최고로 만드는 방법은?’ 같은 질문에 답하기에 사람이 일일히 하기 너무 힘든 작업들을 컴퓨터에게 맡기는건 당연해 보입니다. 그런만큼 알고리즘 성능을 좌우하는 '얼마나 자주 반복 하느냐'와 '얼마나 많은 자원을 사용하느냐' 가 매우 중요한 문제가 되겠지요.

문제는 이 고민이 조금만 복잡해지면 사람이 머릿속으로, 또는 종이에 그려서 표현하기에 너무 복잡한일이 되버림과 동시에 컴퓨터가 너무 많은 시간과 자원을 사용해버리게 된다는 겁니다.

![img](https://cdn-images-1.medium.com/max/1600/1*78cpMT1AOold_QYFIjuRLA.png)

일전에 살펴본 이항계수를 예로 들어보겠습니다. 
$$
_{4}C_{2}
$$
를 구하기 위해 점화식에 의해 재귀적으로 값을 호출하면 위 그림의 과정을 겪게 됩니다. 조금만 숫자가 커지면 사람이 일일이 하기 어렵기 때문에 대표적인 DP 문제가 됩니다. 문제는 위 그림처럼 bino(2.1)은 두번 호출되고, bino(2,1)을 구하기 위한 bino(1,0)과 bino(1,1)은 더 많은 횟수가 호출되게 됩니다. 때문에 이를 다시 재연산하는 비용을 고려하여 사전에 문제 공간 복잡도에 해당하는 크기만큼의 배열을 미리 선언해 놓고, 계산된 값이 존재할때마다 꺼내서 쓰는 **‘메모이제이션'** 방식을 사용합니다. 

사실 얼렁뚱땅 넘어가긴 했습니다만 우린 위 케이스를 통해 이미 분할정복과 동적계획법의 개념을 모두 알게 되었습니다. 분할정복이 문제를 유의미한 수준으로 계속 작은 단위로 쪼개서 최소 단위(보통 base condition에 마주하는 상황입니다)로부터 다시 답을 재조합하는 것이라면, 동적계획법이 등장한 배경은 이런 분할정복 과정에서 어떤 부분 문제가 둘 이상의 문제를 푸는데 사용될 수 있는 상황을 효과적으로 해결하기 위한것에서 비롯되었습니다.

때문에 기본적으로 DP는 재귀 호출을 통한 문제 풀이이자 메모이제이션을 활용하여 시간-공간의 tradeoff를 적절히 조화한 방식이라고 봐야합니다. 즉 분할정복과 동적계획법은 완전히 배치되는 두 개념이 아닌, 일종의 발전된 패러다임이라고 보는편이 더 나을듯 합니다. 

또한 분할정복도 그렇지만 DP가 어렵다고 느껴지는 이유는 가장 핵심인 ‘문제를 어떻게 쪼개야 할지 몰라서' 라고 생각합니다. 이 부분은 정확한 답이 존재하지는 않습니다만 기본적으로 ‘재귀'라는 키워드로 볼 때 몇가지 해답을 제시해 볼 수 있지 않을까 싶습니다.

#### 재귀

부분 문제로부터 전체 문제를 해결해 나가는 개념으로 이해되는 재귀는 이해하기 참 난감한 친구입니다. 직관적인듯 아닌듯 아리송한 녀석이지요. 이는 어떤 문제가 재귀 방식으로 풀리기 위해선 ‘부분 문제를 정의' 할 줄 알아야 하기 때문인데 사실 이 부분이 가장 핵심이자 어려운 부분이기 때문입니다. 어떻게 문제를 쪼개야 잘 쪼개는 방법이 될 수 있을까요?

문자열을 거꾸로 뒤집어 출력해주는 `string_backward`에 대해 생각해 보겠습니다. 이를테면 ‘hello’가 입력이라면 ‘olleh’가 출력되는 형태를 말합니다. 이를 재귀적으로 해결하기 위해서 첫번째 방식은 마지막 글자를 적고 부분 문제 호출을, 두번째 방식은 부분 문제를 호출하고 첫번째 글자를 적는 방식을 택하고 있습니다. 

```cpp
void string_backward(string s){
  if(s.size() == 1){
    printf("%s", s.c_str());
  }else{
    char last_char = s.c_str()[s.size()-1];
    printf("%c", last_char);
    string_backward( s.substr(0, s.size()-1));
  }
}
```

```cpp
void string_backward(string s){
  if(s.size() == 1){
    printf("%s", s.c_str());
  }else{
    char first_char = s.c_str()[0];
    string_backward( s.substr(1, s.size()-1));
    printf("%c", first_char);
  }
}
```



결과는 같습니다만 전자는 ‘거꾸로 적는다' 에 집중하여 ‘적고 — 호출' 을 취하는 반면 후자는 base condition을 마주할때까지 어떠한것도 출력해내지 못합니다. 즉 ‘적는 행위' 자체는 down-top을 취하고 있다는 것을 알 수 있죠. 때문에 저는 재귀 자체가 down-top 방식의 문제 풀이라고 보지는 않습니다. 결국 답을 조합해 내는 과정이 down-top 이냐, top-down이냐가 중요할 뿐이지요.

매우 간단해 보이는 풀이지만 사실 재귀를 처음 접하는 사람들에겐 위 문제 해답을 고민하기가 쉽지는 않습니다. 그럼 본론으로 돌아가 어떻게 문제를 쪼개는 기준을 잡아야 할까요? 

‘부분 문제로부터 전체문제를 해결한다'는 기본에 다시 충실해 볼 필요가 있어 보입니다. 사실 함수가 호출된 입장에서 본다면 자신이 최초로 불렸는지 확인할 수 있는 방법이 있을까요? 다르게 질문해 보겠습니다. main 함수로부터 `string_backward`가 불렸다고 할때, 그리고 지금 어떤 재귀 함수 내부에 있을때, 과연 해당 함수는 자신이 main으로부터 불렸는지, 아니면 `string_backward` 함수로부터 불렸는지 알 수 있을까요? 우린 자연스럽게 정의된 함수 자체가 현재 문제(전체 문제)라고 가정하고 보는 경향이 있습니다. 하지만 ‘재귀적 문제 풀이'가 가능하려면 함수에 주어진 문제는 *그 자체로 전체이자 부분이 될 수 있어야* 합니다. 즉 부분 문제는 전체 문제와 완벽하게 닮아있고 따라서 문제를 쪼갤 수 있다면, 문제를 큰 사이즈로 키울수도 있어야 합니다. 따라서 문제를 쪼갤때는, 부분문제를 정의할때는 지금 주어진 조건들로 구성할 수 있는 전체 문제를 정확히 닮아 있게끔 만드는 수준으로만 쪼개주면 됩니다. 

한 술 더 뜨자면 ‘주어진 조건' 이라 함은, 그리고 재귀 함수 컨텍스트 각자가 자신이 전체인지, 부분인지 알 수 없다(=구분할 필요가 없다)는 것은 함수가 호출될 때 주어지는 인자들(parameter)가 문제를 정의하는 조건들이라는 것입니다. 이 때문에 적절한 수준의 재귀를 벗어날 경우 호출되는 스택마다 해당 파라미터를 복사해서 들고 있어야 하므로 maximum stack call이 발생할 수 있다는 점도 주의해야 합니다. 

정리하자면 내가 지금 마주한 문제가 전체인지 부분인지 알 수 없다는 시각으로 문제를 바라봐야 하며 재귀적 구현은 부분 문제가 전체 문제를 ‘자연스럽게' 해결해 줄 것이란 ‘믿음'이 바탕이 되어야 합니다. 

#### 최적하위구조

down-top 방식의 문제 풀이가 주어진 문제에 ‘최선의 답'을 제시할 수 있으려면, 우리가 매 순간마다 풀어내는 부분 문제가 전체 문제로 재조합 되는 과정에서 항상 최적의 구조를 유지해야 합니다. 

가령 사이즈 n의 문제를 풀고 있는 과정이라고 합시다. 그리고 이 n을 통해서 우린 n+1 사이즈의 문제 답을 구해낼 것입니다. 재귀를 통해서 사이즈 n의 문제가 ‘최선의 답'을 반환했다는 ‘믿음'이 있기 때문에 우린 자연스럽게 사이즈 n+1의 문제의 ‘최선의 답'을 반환 할 수 있게 됩니다. 이처럼 동적계획법은 기본적으로 down-top 방식으로 재귀를 구조화 하기 때문에 현재 수준의 부분 문제에서 최선의 답을 caller에게 제시해 주기만 하면 됩니다.



#### 2574번: 계단오르기

문제는 <https://www.acmicpc.net/problem/2579> 에서 확인해보실 수 있습니다.

![img](https://cdn-images-1.medium.com/max/1600/0*Eulk-KHS_6MZxJkz.png)출처: <https://www.acmicpc.net/problem/2579>

주어진 문제를 동적계획법으로 풀기 위해서, 어떻게 문제를 정의해야 할까요? 재귀만 생각해도 머리가 아플텐데, ‘동적계획' 이란 말까지 쓰려니 버겁습니다. ‘재귀' 만 생각해 볼까요? 문제를 재귀적으로 바라본다는 것은, 문제를 푸는데 있어서 호출될 우리가 정의하는 함수가 ‘조건들' 을 매개변수(parameter)로 받을것이고, 이것 만으로 재귀 문제를 푸는것이 가능해야 합니다. 어떤 조건들이 필수적일까요?

우리가 어떤 계단에 이미 있다고 생각해 봅시다(부분 문제 상황에 놓여있다고 생각하는 겁니다). 그렇다면 우리가 이 다음 결정을 내리기 위해서 다음의 정보들을 요구하게 될겁니다. 

- 지금까지 내가 연속해서 몇 계단을 오른것인가?
- 나는 지금 몇 번째 계단에 위치해 있는가?

간혹 ‘지금까지 내가 얻은 점수는 몇점인가?’가 궁금해질 수 있습니다. 하지만 정말 필요한 정보인지 물어봅시다. 우리가 지금까지 몇점을 얻었건 우리의 다음 스텝에는 영향을 미치지 못합니다. 우린 ‘앞으로 얻을 점수를 최대화'할 생각을 해야하기 때문입니다. 때문에 주어진 문제는 다음과 같은 함수로 정의할 수 있습니다.

> 연속해서 오른 계단수와, 지금 계단 위치 정보를 바탕으로 앞으로 계단을 올라간다고 할때, 얻을 수 있는 점수의 최댓값

그럼 앞으로 얻을 점수의 최댓값을 어떻게 알 수 있죠? 궁금해할 필요가 없습니다. 지금이 전체 문제라고 믿고 있는 우리에게 있어서 해당 문제는 ‘부분 문제'이므로 더 작은 사이즈의 재귀 호출을 통해 그 값을 얻어낼 수 있기 때문입니다. 



#### 1005번: ACM Craft

정답률이 18%라는데 사실 동적계획법 자체가 어려운 문제는 결코 아닙니다. 

![img](https://cdn-images-1.medium.com/max/1600/1*uh9XFMhS9CV7tjtwrvuTLA.jpeg)

가령 4번 건물을 지어야 하는 상황이 문제로 주어졌다고 합시다. 우린 또다시 의심해 볼 필요가 있습니다. 우린 정말 4번 건물을 푸는것이 전체 문제일까요? 혹시 ‘4번 건물을 지어야 한다'는 상황이 부분문제로 호출되었고 이를 우리가 현재 마주한것은 아닐까요? 

이런 생각에 기초해서 우리의 부분문제는 반드시 ‘현재 지어야 하는 건물'이 조건으로 강제됩니다. 따라서 재귀 함수는 인자로 반드시 ‘지어야 하는 건물 번호'를 필요로 하게 됩니다. 

그럼 우선은 ‘4번 건물을 짓는 것'을 전체 문제로 생각하고 부분 문제들로부터 어떻게 풀어낼지 생각해 봅시다. 4번 건물을 짓는데 사전에 지어져야 하는 건물들은 2번, 3번 입니다. 잠깐, 2번 건물과 3번 건물이 ‘다 지어지기 전까진' 4번을 짓지 못한다는 것은, ‘4번 건물을 짓는 것'을 풀기 위해선 ‘2번 건물을 짓는것' 과 ‘3번 건물을 짓는 것' 을 해결해 내야 함을 의미하죠. 그 중에서도 병목현상에 해당하는 3번 건물을 다짓는데 걸리는 시간을 모조리 기다려야 함도 위와같은 단순한 그림에선 벌써 알 수 있죠. 즉 우리의 문제는 아래와 같이 정의 됩니다.

> n번 건물을 짓는데 필요한 건물들 x1, x2, … 각각을 짓는데 필요한 시간들의 최댓값으로부터 n번 건물을 짓는데 필요한 시간 반환

이 문제가 복잡하게 느껴지는 부분은 입력에서 의존 관계에 있는 건물들을 적절한 자료구조에 관리하는 일 뿐입니다. 이 역시 사실 그래프에서 ‘위상 정렬' 부분을 알고 있다면 쉽게 구현할 수 있을것입니다(흥미로운건 위상정렬 또한 재귀적으로 풀어낼 수 있습니다).