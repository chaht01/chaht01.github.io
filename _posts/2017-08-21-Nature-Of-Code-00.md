---
layout: post
title:  "Nature of code 0. 소개"
date:   2017-08-21 13:57:55 +0900
categories: NatureOfCode
comments: true
---

생물, 자연 현상을 표현하기 어려운 이유는 이를 이루는 각 개체의 행동 양식을 어떤것 하나로 규정하기 어렵기 때문일 것입니다. 따라서 보통은 임의의 값(random)으로 다양성을 표현합니다만 임의의 값을 선택하는 일은 생각보다 어렵습니다. 
Nature of code 0장에서는 말은 ‘소개' 지만 가장 기본적인 ‘임의 값 선택'에 대해 다루고 있습니다. 아래는 이에대해 공부한 내용을 다룹니다.


모든 프로세싱 시각화에 앞서 객체 지향 프로그래밍에 대해 아주 잠깐 다루고 있습니다. 본 예제에서는 Walker 객체를 통해 생물의 랜덤한 움직임을 점의 경로로 표현합니다. 


### random()함수 ###

가장 기본적으론 random함수를 많이 사용하는듯 합니다. 하지만 대부분의 random 함수는 실제로 무작위라고 볼 수 있는 값을 반환하지 않습니다. 랜덤하게 보이는 값을 줄 뿐입니다. 

### 확률과 비균등 분포 ###
또한 실제 자연계를 표현하는데 있어서 완전히 모든 값들이 **‘비슷한 확률로 나오는'** 케이스는 크게 흥미롭지 않습니다. 경우에 따라 어떤 자연 생태계에선 귀가 큰 여우가 그렇지 않은 여우보다 많이 태어나야 할 수도 있습니다.

이처럼 실제 자연계의 특정 형질에 대한 ‘비균등 분포'를 표현하귀 위해 다음 두 트릭을 사용해 볼 수 있습니다.
* 사건을 담고있는 배열에 확률적으로 높게 나타나야 할 사건을 여러번 담는 방법
* random() 함수와 같이 ‘균등 분포'를 가진 함수의 결과값으로부터 ‘특정 범위 일때'를 사건 선택의 기준으로 하는 방법


```java
float r = random(1);
if(r < 0.4){
  // 40%의 확률로 발생하는 사건
} else {
  // 60%의 확률로 발생하는 사건
}
```

### 정규 분포 ###
정규 분포 또한 실제 자연계를 표현하기 좋은 분포중 하나입니다. 이를 사용하기 위해선 몇가지 과정이 필요합니다만 크게 어렵지 않으므로 아래 코드로 대체합니다.

```java
import java.util.Random; // 정규분포로 임의의 값을 추출하기 위해 불러옵니다.
Random generator;
generator = new Random();
float num = (float) generator.nextGaussian(); // generator를 통해 정규분포내 임의의 값을 불러옵니다.
```




### 사용자 정의 분포 ###
이 부분이 ‘Nature of code’를 보면서 좀 의아하면서 재밌던 부분이기에 자세히 소개하겠습니다. 우리가 매 순간마다 랜덤하게 나아갈 방향을, 그리고 나아갈 보폭을 선택한다고 하면 이것 자체로는 문제될게 없어 보입니다. 하지만 실제 자연계에서의 ‘움직임'은 에너지가 수반되는 작업이고, 에너지를 사용하는 만큼 자신이 얻고자 하는 것을 찾기위한 여정일 가능성이 높죠.


문제는 **''임의의 스텝 선택'**'이 가장 효율적인 경로 선택을 보장해주진 못한다는 것입니다. 즉 실제 의지를 갖고있는 개체나 군집의 모습을 단순 랜덤으로는 표현하는건 자연스럽지 않습니다. 왜냐하면 갔던곳을 또 가는 ‘오버 샘플링(over sampling)’이 발생하기 때문입니다. 


책에서는 이를 해결하기 위해 아주 가끔씩 굉장히 먼곳으로 가버리면 된다고 말합니다. 즉, 가까이 갈 확률을 크게, 멀리갈 확률을 작게 만들자는 아이디어 입니다. 이를 레비의 비행(Levy’s flight)라고 합니다.


근데 이때 ‘멀리' 라는 것 또는 ‘가까이' 라는 것을 단순히 임의의 값을 선택할 범위로 정해주는 방식보단 멀리가게 되었을때, 이왕이면 더 먼거리를 더 높은 확률로 선택하게끔 조정합니다. 이게 무슨말인가 한참을 해맸는데 아래와 같이 생각할 수 있습니다.
* 어쩌다보니 이번이 멀리갈 차례입니다(아주 드문 경우입니다)
* 흔치 않은 기회이므로 이왕이면 먼 거리를 높은 확률로 이동하고자 합니다.

즉 *‘큰 숫자는 높은 확률로 선택한다'*를 구현해야 하는 문제가 되며 이를 <u>‘몬테카를로 확률(Monte Carlo)’</u>로 책에서는 부릅니다. 어떻게 구현해야 큰 숫자를 높은 확률로 얻어낼 수 있을까요?
책에서는 두 숫자(0~1 사이, 각각을 a, b라 부르겠습니다)를 랜덤하게 선택하는것에서 아이디어를 시작합니다. 이는 앞서 비균등 분포에서 소개했던 부분과 유사한데, a가 만일 충분히 큰 숫자라면 당연히 b는 a보다 작을 확률이 높아집니다. 즉, a는 a 스스로를 선택할 기준이 되는 것이며, 만에하나 b가 a보다 크게 되더라도 a와 b를 다시 뽑아서 전체 과정을 반복하면 그만입니다. 정리하면
* a>b : a를 리턴합니다. 
* a<b : a와 b를 다시 뽑습니다.
* 설령 a가 정말 작은 값이면서 a>b를 만족할수도 있겠지만, a가 크면서 a>b인 경우보다 매우 희박하게 나타날 것입니다. 즉 ‘큰 숫자를 높은 확률로' 뽑는것이 가능해집니다.

그럼 실제로 레비의 비행을 구현하기 위한 몬테카를로 확률 분포는 큰값을 더 많이 뽑는 분포를 가질까요? 아래 확률 분표 그래프를 확인하시면 쉽게 답을 얻으실 수 있을거라 봅니다.

![Imgur](http://i.imgur.com/fLOIKWG.png)
### 펄린노이즈 ###
마지막으로 책에서는 펄린노이즈(Perline noise)를 소개하고 있습니다. 펄린 노이즈는 실제 해당 노이즈를 제안한 펄린의 이름을 붙였습니다. 프로세싱에선 간단하게 noise() 함수로 랜덤값을 구해낼 수 있습니다. 펄린노이즈가 랜덤한 값을 뽑아내는데 있어 유용한 이유는, 시계열 데이터나 연속된 분포를 표현해야하는 랜덤 상황들(대부분의 자연계가 사실 해당된다고 볼 수 있는듯 합니다)에 있어서 자연스러운 노이즈를 0과 1사이 값으로 표현해주기 때문입니다. 때문에 펄린노이즈는 영상에 있어서도 구름, 대리석 문양 등에도 쓰입니다. 
펄린노이즈는 1차원부터 3차원까지 그 값을 표현해주며, 입력으로 ‘시간' 개념의 변수를 받습니다. 연속된 시간에 따른 자연스러운 노이즈 값을 리턴해주는 형태인데, 1차원이면 선형으로, 2차원은 면적에 대해, 3차원은 공간에 대해 값을 리턴해줍니다.
왼쪽은 펄린노이즈로 움직이는 원형의 경로를 표현한 것입니다. x, y 뿐 아니라 이동하는 원형의 크기까지 펄린노이즈로 표현해 보았습니다.

![Imgur](http://i.imgur.com/BeQWn3V.png)

