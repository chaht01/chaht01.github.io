---
layout: post
title:  "이항계수 문제풀이"
date:   2017-08-21 13:57:55 +0900
categories: Algorithm
comments: true
---

백준 2407 문제와 6591 문제를 통해 이항계수에 대해서 알아보고자 합니다.

이항계수는 넓은 의미에서 ‘조합'이라고 불리기도 합니다. 순서대로 뽑는 구별되는 여러 케이스의 의미로서 ‘순열'과 달리 ‘조합'은 ‘총 몇개중에 몇개를 선택하기'로 해석되는 경우 쓰입니다. 

이항계수는 아래와 같은 규칙으로 얻어질 수 있습니다.

 
$$
(\begin{matrix} n \\ k \end{matrix})= \begin{cases} n!/(n-k)!k! & \text{if } n > k \\0 & \text{if } k<0 \\ 0 & \text{if }
k>n\end{cases} 
$$

또한 nCk = n-1Ck + n-1Ck-1 의 점화관계를 통해 재귀적으로 그 값을 구해낼 수 있습니다.

### 2407번 : 조합

주어진 문제는 단순히 nCm을 구하는 문제지만 n과 m의 범위에 유의할 필요가 있습니다. n이 100이하의 자연수가 될 수 있기 때문에 실제 이항계수의 최대값은 100C50 으로 100891344545564193334812497256이라는 어마어마하게 큰 값이 나오게 됩니다. 정수의 최대 범위가 -2,147,483,648 ~ 2,147,438,647 이고 이보다 훨씬 큰 long long 의 범위도 –9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807에 불과하다는것을 깨닫는다면 일찍이 이 값을 어떠한 형태의 primitive type 자료형에 담아 출력해내는것이 불가능하다는것을 알 수 있습니다.

따라서 이 문제는 어떠한 형태로 계산과정을 최적화 하던간에 결국 출력에 문제가 생기기 때문에 Big Integer 또는 그에 상응하는 큰 숫자 표현 방식을 고안해 내야합니다. 

c++에는 내장된 Big Integer가 없으나 해당 문제가 뺄셈이나 나눗셈을 필요로 하지 않음을 빠르게 파악한다면 크게 구현이 어려울것은 없습니다.

이 문제를 빠르게 해결하기 위한 흔한 노력들을 보시겠습니다.

- 소수를 활용 : 어차피 100이하의 소수를 구하는 일은 log(n^(1/2)) 안에 해결됩니다. 따라서 소수 목록을 미리 구해둔 뒤 분자와 분모의 각 소수별 지수를 카운트해놓고 나중에 계산하는 방법을 써볼 수 있습니다.
- 절반만 계산하기 : 어차피 nCr = nCn-r이 성립되고, n보다 큰 r에 대해선 그 값을 구할필요가 없으므로, N * N 행렬에 대해 각 값을 메모이제이션 한다고 할 때, 실제론 그 절반도 안되는 크기에 값을 메모이제이션 해 둘 수 있습니다.

물론 저도 위와 같은 노력들을 했고, 실제로 제 코드는 200줄이 넘어가는 다소 지저분한 괴물로 변해있었습니다. 아무래도 다시보더라도 이해가 갈만한 코드를 짜려던 제 욕심때문에 벌어진 일 같습니다만 200줄이나 넘는 코드를 다시보고 싶어하는 사람이 없을거라는 점에서 ajh8894님이 푸신 아주 간결하지만 이번 문제 풀이에 최적인 풀이를 보시겠습니다.

원리는 단순합니다. 심지어 사실 a 배열의 크기가 10인것도 중요하지는 않습니다. 중요한 사실은 오직 배열 원소 하나에 4자리수를 표현할 것이고, a[0]에서 a[9]으로 갈수록 높은 자리수를 표현하게 된다는 점 뿐입니다. 즉 Big Integer를 단순히 배열로 옮겨놓은것입니다. 하지만 이 간결한 코드로도 ‘어차피 덧셈, 곱셈으로 인해 값이 커지기만 할 것' 이라는 계산 과정에 대한 이해가 포함되어 있습니다. 또한 이를 효율적으로 구하기 위해, 어차피 nCr에서 약분되어 사라질 분자의 r!까지의 부분을 효율적으로 제거함과 동시에, 쉽게 증가되버리는 분자의 값을 분자따로, 분모따로 구한뒤 연산하는 것이 아니라 분자에 곱하고, 분모에 나누고 하는 과정을 번갈아 함으로서 연산을 최적화하고 있습니다. (더 자세히 설명 할것)

### 6591번 : 이항쇼다운

얼핏보면 쉽지만 생각보다 고려할 요소가 많은 문제입니다. 역시나 nCk를 구하는 문제입니다만 독특하게도 n과 k의 범위가 주어지지 않았습니다. 대신에 입력으로 받는 n, k는 그 조합 값이 2³¹보다 작게 만드는 n, k가 주어진다고 명시해놓고 있습니다. 

앞서 2407 문제를 겪고나면 굉장히 쉽게 느껴집니다. ‘아 이미 정수 범위를 넘어서는 숫자를 다뤄봤는데, 고작 2³¹ 보다 작은수?’ 라고 생각하기 쉽습니다. 이러한 생각이 쉽게 오류를 만드는 이유는, 자연스레 n의 범위를 정하게 되고(또는 입력으로 받는 n으로 동적 할당하게 되겠지요) 이 n으로 메모이제이션 공간을 사용하려 시도하게 된다는 것입니다. 

2³¹ 보다 작은 정수 즉 최대 2³¹-1 (정수 자료형의 최대값입니다) 까지의 값이 나오는 n과 k는 어떤 값들이 가능할까요? 조금만 생각해 본다면 n=2³¹-1, k=1인 경우가 가능하다는 것을, 그리고 더 나아가 이를 메모이제이션을 하기 위해선 (2³¹-1)*(2³¹-1)의 공간이 정수형 자료에 대해 필요하다는 사실을 알게 됩니다(무조건 주어진 메모리에선 불가능하다고 보면 됩니다).

그럼 슬라이딩 윈도우를 써보면 어떨까요? 모든 행을 다 기억할 필요 없이 어차피 nCk = n-1Ck + n-1Ck-1이니 가능해 보입니다만 결국 열의 갯수가 최대 2³¹-1개 필요하게 되므로 이역시 못할짓입니다. 더군다나 ‘혹시라도' 메모리가 빵빵하게 주어져서 가능하다고 할지언정, 점화 관계를 통해 해당 값에 도달하기 위해 O(n)의 계산을 수행 제한 시간 1초안에 해내는건 불가능합니다.

핵심 아이디어는 ‘항상 정답이 2³¹ 보다 작은 경우만 입력으로 주어진다'는 조건입니다. 문제를 어렵게 만드는 요소이면서 동시에 문제를 풀리게 만들기 때문입니다. 

무슨 뜻인고하니 어차피 nCr에 대해 분자에는 n!, 분모에는 r!(n-r)!이 위치하게 되고, 이들을 약분한 값이 nCr이 됨을 알 수 있습니다. 이값이 무조건 2³¹ 보다 작다는 것은, 모두 약분하여 분모가 1이 되는 순간 분자를 계산해볼만 하다는 의미입니다. 또한 100C50을 계산했을때 일찍이 정수 범위를 벗어난 경험을 돌이켜 보면 r과 n-r 중 작은 값은 문제의 특성상 절대로 50조차도 될 수 없다는 것을 알 수 있습니다. 

따라서 다음과 같은 트릭을 연산 과정을 생각해보도록 합니다.

r과 n-r 중 작은값을 less라 할때, 어차피 분자에는 
(n-less+1) * (n-less+2) * … * (n)
분모에는
less!
연산만이 존재하고, 결국에는 분모의 less! 또한 분자에 의해 약분될 것이라는 사실입니다. 

따라서 분자의 각 인수를 실제 연산하지 않고, less이하의 정수들에 대해 less!를 소인수들의 곱으로 모두 표현해 놓습니다. 이 아이디어는 앞서 2407에서 사용한 아이디어와 유사하죠. 

또한 이 소인수들로 차례로 분자를 나눠보는 연산은 따로 머리를 써가면서 효율적으로 해보지 않더라도 많아야 O(less²) 연산만이 소요될 뿐입니다. 따라서 우리는 ‘입력이 유효하다는 전제' 하에 n과 r에 얼마나 큰 값이 들어오건 소수를 구하는데 O(less^(1/2)), 약분하는데 O(less²), 실제 값을 구해내는데 O(less) 만큼만의 시간만 소요하여 답을 도출해낼 수 있습니다. 